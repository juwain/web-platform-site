---
title: "Пульс веб-платформы 01.11.2024"
description: "Новости веб-платформы"
pubDate: "Nov 01 2024"
heroImage: "/blog-placeholder-pulse.jpg"
tags: ["Пульс_веб_платформы"]
---

**Новости**

- [обновилась Node до v23.1.0](https://nodejs.org/en/blog/release/v23.1.0): стабилизировано встроенное в 'node:test' MockTimers API, позволяющее замокать системное время `mock.timers.enable({ apis: ['Date'], now: new Date('1970-01-01') });`, а также теперь стабильны JSON modules и import attributes — это когда к импорту JSON-файла приписывается уточнение `with { type: 'json' }` для повышения безопасности, чтобы среда проверила, что внутри действительно JSON (также с [выходом Node 22.11.0](https://nodejs.org/en/blog/release/v22.11.0) все дальнейшие 22.x-релизы будут считаться LTS)
- [состоялся первый митинг рабочей группы JSR](https://docs.google.com/presentation/d/195gc4ut4gJ6kbgxlLfCKws0pY505c7uNWbmIoap2CkQ/edit#slide=id.p) (аналог npm от создателей Deno), из слайдов можно узнать, что: JSR не всегда может опубликовать существующий проект на `.js + .d.ts`; хостинг проекта стоит ~$400 в месяц; хотят сделать тул для генерации JSR-конфига из `package.json`
- [Apple пошла на уступки](https://open-web-advocacy.org/blog/apple-implements-six-of-owas-dma-compliance-requests/) контролирующим органам в EU и добавила в новой бете iOS послабления (только для EU) в истории с монопольностью Safari: браузерные вендоры теперь могут включать бинарник с собственным движком в браузер, но он всё равно будет использоваться на пару с webkit, правда тестировать это дело за пределами EU всё равно нельзя; выбор браузера по умолчанию появится в более заметном месте и в явном виде; Safari можно будет удалить из системы
- [вышел Firefox 132](https://www.mozilla.org/en-US/firefox/132.0/releasenotes/): улучшена поддержка аппаратного ускорения для SVG-фильтров; HTTP-фавиконки будут блокироваться, если их невозможно получить через https; поддержан атрибут `fetchpriority`

**Проекты**

- [nvm-desktop](https://github.com/1111mp/nvm-desktop) — собранный на Tauri кроссcистемный десктопный клиент Node Version Manager
- [node-html-to-image](https://github.com/frinyvonnick/node-html-to-image) — Node-надстройка над puppeteer, чтобы отрендерить страницу и снять скриншот (опционально поддерживается Handlerbars для разметки)
- [DuckDuckGo AI Chat](https://duckduckgo.com/aichat) — через сервис можно бесплатно и без VPN пользоваться чатом с моделями GPT, Claude, Llama, Mixtral
- [html-](https://github.com/knowler/html-/) — попытка воссоздать стандартные HTML-элементы с помощью веб-компонентов (которая обречена на провал, но смотреть интересно); вот, например, [кнопка](https://github.com/knowler/html-/blob/main/button-element.js)

**Статьи и демки**

**JS**

- [нативная поддержка TS в Node](https://samthor.au/2024/node-run-typescript/) уже сама по себе хороша, но также позволяет импортировать TS-файлы просто так `const module = await import('./module.ts');`; включить можно экспериментальным флагом при запуске Node, в том числе в сразу внутри `.bashrc`: `export NODE_OPTIONS="--experimental-transform-types --disable-warning=ExperimentalWarning"`
- ручной вызов метода `submit()` у формы совершит отправку не учитывая валидации и не запуская события `submit`; а чтобы перед отправкой формы триггерить событие и проводить валидации, [есть давно доступный в браузерах метод `requestSubmit()`](https://www.stefanjudis.com/today-i-learned/requestsubmit-offers-a-way-to-validate-a-form-before-submitting-it/)
- [пример реализации микрофронтендов](https://blog.cloudflare.com/fragment-piercing/) с помощью Cloudflare Workers: приводится пример реализации с гейтвеем, через который проходят все запросы, и который отдаёт нужный микрофронт, а также с кастомными элементами для обозначения, куда инжектить микрофронт и с общей шиной событий (честно говоря, это уже почти похоже на набор iframe-ов, в которых грузятся независимые страницы)
- [«нативное» управление светлой-тёмной темой](https://css-tricks.com/come-to-the-light-dark-side/) через `<meta name="color-scheme" content="light dark">` прикольно тем, что можно буквально найти meta-элемент через `document.querySelector` и менять его значение
- «нативная» валидация форм (атрибут метод `setCustomValidity` у инпутов) позволяет на коленке сделать проверку введённого значения в инпуты и отобразить это в виде системного уведомления ([пример для React](https://expressionstatement.com/html-form-validation-is-heavily-underused))
- [`File` — это расширение `Blob`](https://jsdev.space/file-blob-js/), с добавленными методами `name`, `size`, `type`, `lastModified`, `webkitRelativePath`

**CSS**

- селектор `.container:has(.element:last-child:nth-child(-n + 3))` применится, если в контейнере содержится 3 или меньше количество элементов, удобно, к примеру, [для перестроения грида](https://piccalil.li/blog/making-content-aware-components-using-css-has-grid-and-quantity-queries/)
- [гайд](https://css-tricks.com/unleash-the-power-of-scroll-driven-animations/) по Scroll-Driven Animations (пока доступны только в Хромиум-браузерах): киллер-фича — разгружается основной поток браузерного движка и поэтому анимации получаются гарантировано более плавными ([бонусом пример](https://frontendmasters.com/blog/scroll-driven-sections/) связки анимации кастомного свойства посредством скролл-анимации)
- с частым появлением новых фич в CSS можно регулярно их обновлять в CSS Reset; в [предлагаемом варианте](https://jakelazaroff.com/words/my-modern-css-reset/) используются `@layer`, чтобы подключать стили не обязательно в самом начале , и нативная вложенность селекторов `:not([class]) { h1& {…}}`
- [использование полупрозрачного цвета вместо сплошного](https://evilmartians.com/chronicles/woah-opacity-a-full-guide-to-this-badass-hero-of-efficient-ui-design) — хороший лайфхак, чтобы не плодить цвета для разных состояний кнопок или рамок, годится для приложений с несколькими цветовыми темами

**Платформа**

- [сборник рекомендаций по улучшению Core Web Vitals](https://web.dev/articles/top-cwv), из интересного: в Chrome есть вкладка Coverage, чтобы увидеть загруженный, но неиспользующийся код; картинки лучше всего подключать в `<img src|srcset>`, так они начинают грузиться раньше, а не ждут загрузки стилей/скриптов; не стоит пользовать событие `unload` и заголовок `Cache-Control: no-store`, так как они мешают браузеру доставать страницу из кеша при переходе «назад»
- обычно поиском по истории коммитов пользуешься, чтобы посмотреть, кто что изменил в конкретном файле или строке файла; а вот `git log` с ключом `-S` — [«поисковик» по диффам коммитов определённой строки](https://alexharri.com/blog/searching-and-navigating-git-commits), не привязываясь к конкретному файлу
- [недавно писал dev-fiction](https://t.me/web_platform/142), где предполагал появление web-components-фреймворка от Google и «глобального UI-kit-а», помните? Как вы возможно догадались, «прототипы» не были взяты мной из воздуха. Фреймворк самом деле существует — это [Lit](https://lit.dev) (остаётся довезти туда [нативные сигналы](https://lit.dev/blog/2024-10-08-signals/), упростить SSR, добавить тесную интеграцию с дев-тулзами и включить маркетинговую машину), а прототип «глобального» UI-kit-а — это [Shoelace](https://shoelace.style) (недавно переродившийся в Web Awesome), основанный на Lit (остаётся перестать быть местечковым проектом одного человека). Так вот, я к чему веду: посмотрите на [код веб-компонента](https://github.com/web-platform-dx/baseline-status/blob/main/baseline-status.js) статусной плашки, у меня этот код вызывает приятные ощущения, а у вас?
