---
title: "Пульс веб-платформы 12.07.2024"
description: "Новости веб-платформы"
pubDate: "Jul 12 2024"
heroImage: "/blog-placeholder-pulse.jpg"
---

**#Пульс*веб*платформы 12.07.2024**

**Новости**

- [вышел pnpm v9.5.0](https://github.com/pnpm/pnpm/releases/tag/v9.5.0): появились catalogs-алиасы, чтобы один раз в конфиге объявить набор зависимостей, например, `catalogs: react16: react: ^16.7.0 react-dom: ^16.7.0`, а затем в `package.json` писать алиас вместо версии напрямую `"dependencies": { "react": "catalog:react16", "react-dom": "catalog:react16" }`; так можно лайтово организовать монорепу без оверхеда на одном пакетном менеджере
- [SQLLite завезут в Nodejs](https://github.com/nodejs/node/pull/53752) для реализации `localStorage`/`sessionStorage`, а заодно откроют возможность его использования просто так; всё таки там, где есть борьба или хотя бы конкуренция, сразу идёт развитие (спасибо Bun и Deno)
- [вышел Firefox 128](https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/128): появился встроенный в браузер переводчик, включен relative color syntax, поддержан [альтернативный текст](https://developer.mozilla.org/en-US/docs/Web/CSS/content#alternative_text) для свойства `content`, заработала директива `@property` и `registerProperty()`, а также появился Resizeable ArrayBuffers
- вслед `@property` в [FF вскоре появится и @starting-style](https://front-end.social/@floscholz/112761020096320324), то есть он будет во всех браузерах
- после недавних больших обновлений eslint [начинается перелопачивание архитектуры](https://eslint.org/blog/2024/07/whats-coming-next-for-eslint/): появятся отдельные пакеты для линтинга не-JS-файлов (json, md), агностик-ядро и пакеты переедут в новую репу, будет написан новый CLI; в общем, за этим крайне интересно наблюдать, как именно в большом проекте справляются с архитектурными проблемами, миграцией, и справятся ли в итоге
- [вышел vitest v2.0.0](https://github.com/vitest-dev/vitest/releases/tag/v2.0.0): браузерный режим работы, брейкинг-изменения, багфиксы

**Проекты**

- [fast-json-stringify](https://github.com/fastify/fast-json-stringify) — более быстрый аналог `JSON.stringify()`, если скормить ему схему JSON, который нужно распарсить
- [nolyfill](https://github.com/SukkaW/nolyfill) — `npx nolyfill` уменьшит содержимое `node_modules` за счёт выпиливания ненужных более полифиллов
- [es-toolkit](https://github.com/toss/es-toolkit) — новый более быстрый и компактный аналог lodash (который в свою очередь был более быстрым аналогом underscore)
- [react-jsx-parser](https://github.com/TroyAlford/react-jsx-parser) — React-компонент парсер JSX (если нужно распарсить в JSX динамически формируемую строку HTML или JSX)

**Статьи и демки**

**JS**

- написание тестов — тонкая штука, вот и описания идеальных тестов звучат довольно расплывчато, но [как ещё описать тонкие материи](https://web.dev/articles/ta-what-to-test)? Тест — это скорее ассистент, а не математическая формула. Тесты должны быть простыми и сфокусированными на одной вещи. Тестов без причины не должно существовать. Тесты не должны содержать деталей реализации.
- сайт — это то же приложение, но которое не надо отдельно устанавливать/обновлять, а его просто когда нужно открываешь, оно подтягивает данные и работаешь с ним; [если развить идею](https://evilmartians.com/chronicles/recapping-the-first-local-first-conference-in-15-minutes), то сайт может в целом иметь свою БД в браузере (IndexedDB, WASM + SQLite), хранить состояние и, когда есть возможность, синхронизировать состояние с сервером и другими клиентами; так автоматом повысится UX (не нужно на каждый чих ходить на сервер), тем более что современные клиенты позволяют
- [фича Isolated declarations в TS 5.5](https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-10/) меняет то, как можно публиковать проекты: раньше в пакет публиковались отдельно d.ts-файлы и скомпилированные js-файлы, так как их генерация была затратной по производительности операцией; теперь же можно публиковать исходный ts-файл, а артефакты d.ts будут генериться на лету во время установки пакета за счёт более производительного движка
- бывают случаи, когда некорректно созданная мемоизация создаёт утечку памяти за счёт удержания замыкания с большим объектом в нём; печаль в том, что то же самое [может сделать автомемоизатор React Compiler](https://schiener.io/2024-07-07/react-closures-compiler), но дебажить это станет сложнее

**CSS**

- [рецепт градиентной рамки](https://css-tip.com/border-gradient/): с вырезанием маской куска градиента, если нужна прозрачность, и с двойным градиентом (конический + линейный), если без прозрачности
- [мощь свойства clip-path](https://emilkowal.ski/ui/the-magic-of-clip-path) не только в возможности «вырезать» любую форму, но также и анимировать её (нужно в слайдерах, шторках, подложках)
- божественный [селектор :has() всемогущ](https://brucelawson.co.uk/2024/css-has-the-god-selector/) тем, что не требует структурной связи проверяемого селектора и стилизуемого элемента (проверяем одно, стилизуем другое)

**HTML**

- у `<script>` или `<link>` есть [атрибут integrity](https://frontendmasters.com/blog/script-integrity/), в который передаётся хэш, и если содержимое файла скрипта или стилей изменится, а хэш нет, то тогда браузер выкинет ошибку и не выполнит файл (сгенерить хэш можно [тут](https://www.srihash.org/))
