---
title: "Пульс веб-платформы 08.11.2024"
description: "Новости веб-платформы"
pubDate: "Nov 08 2024"
heroImage: "/blog-placeholder-pulse.jpg"
tags: ["Пульс_веб_платформы"]
---

**Новости**

- Nicholas C. Zakas [прорабатывает поддержку ](https://github.com/eslint/rfcs/blob/main/designs/2022-languages/README.md)в ESLint плагинов для других (неES) языков, например, началась работа над [плагином для линтинга CSS](https://github.com/eslint/css/), а что Stylelint по сути делает схожие манипуляции, почему бы не делать это в самом ESLint?
- [часть OSS-разработчиков Flutter создали форк Flock](https://getflocked.dev/blog/posts/we-are-forking-flutter-this-is-why/), из-за недовольства, что баги в оригинальной команде долго фиксятся, планируют активно работать с сообществом, но при этом не отходить от оригинального Flutter (пока что)
- в Mozilla Foundation (НКО) [сократили 30% персонала](https://techcrunch.com/2024/11/05/mozilla-foundation-lays-off-30-staff-drops-advocacy-division/) (отделы advocacy и global)

**Проекты**

- [jsonvisualizer](https://jsonvisualizer-v2.web.app/visualize) — визуализация JSON в виде диаграммы, например, чтобы окинуть взглядом сразу весь ваш развесистый `package.json` или JSON-ину с большой вложенностью
- [codingfont](https://www.codingfont.com/) — шрифтовый батл, чтобы остался тольк один: удобный, моноширинный, твой (у меня победил Source Code Pro)
- [prerender](https://github.com/prerender/prerender) — Node-сервер, который в безголовом Chrome отрендерит SPA и отдаст готовый HTML (например, для поисковиков)

**Статьи и демки**

**JS**

- если отбросить хэллоуинскую тематику, то в одном месте [сравниваются подходы к организации UI-китов](https://nerdy.dev/headless-boneless-and-skinless-ui): headless (безголовый) — кит предоставляет компоненты и минимальные стили, разработчик сам организует CSS для них (Radix Primitives); boneless (безкостный) — кит предоставляет атомарные классы, из которых разработчик уже составляет компоненты (Bootstrap, Tailwind); skinless (безкожный) — как кит предоставляет компоненты, но совсем без стилей (React Aria); lifeless (безжизненный) — набор «голых» хуков и абстрактной функциональности, в которые нужно самостоятельно передать «физическое воплощение», чтобы система «ожила» (TanStack, React Aria Hooks)
- идея: [не использовать try/catch напрямую](https://dev.to/noah-00/no-more-trycatch-a-better-way-to-handle-errors-in-typescript-5hbd), а оборачивать код в функцию, возвращающую промис, а уже внутри этой функции прописать catch у промиса
- пока в Vercel проводят конференции и выпускают новые версии с поддержкой «серверного» React, в мире работает один (на самом деле нет) Tanner Linsley, [пытающийся вернуть React на клиент](https://bobaekang.com/blog/two-ways-to-the-two-reacts/), сделав сервер ещё одним способом работы с асинхронными данными, но при этом оставив прежнюю клиентскую природу React в TanStack Start, очень интересно, что же получится
- [оператор `??=`](https://www.trevorlasn.com/blog/javascript-nullish-coalescing-assignment-operator) позволяет избавиться от бойлерплейтного кода, когда нужно проверить значение на null/undefined и присвоить дефолтное значение: вместо `user.name = user.name ?? 'Anonymous'` пишем `user.name ??= 'Anonymous'`

**CSS**

- свойство `text-wrap: balance` ожидаемо из названия подравнивает длинные многострочные заголовки и короткие тексты, но уже неожиданно может быть использовано для [подравнивания любых inline-элементов, переносящихся на несколько строк](https://shkspr.mobi/blog/2024/10/you-can-use-text-wrap-balance-on-icons/), например, `<li>` с `display: inline-block` и иконками внутри
- в `@layer` можно включать не только reset-стили, но и в целом [любые глобальные стили на весь проект](https://mayank.co/blog/css-reset-layer/), если хочется избежать проблем со нарастающей специфичностью и порядком подключения стилей (`@layer` — это как будто `!unimportant`)
- этот год был богат на урожай CSS-фич, которые ещё несколько лет будут входить в обиход, а пока остаётся просматривать списки фич и запоминать, чтобы при случае удачно применить; в [этом списке](https://argyle-at-devfest-2024.netlify.app/16-user-valid/), например, среди прочего есть упоминание о псевдоклассах `:user-valid` и `:user-invalid`, которыми с связке с `:has()` можно связать стилизацию `<label>` с последующим пользовательским неверным заполнением `<input>`: `input { label:has(+ &:user-invalid) { text-decoration: underline wavy red }}`
- значение `width: stretch`, оно же `-moz-available` и `-webkit-fill-available` несмотря на до сих пор требуемые префиксы, доступная во всех браузерах альтернатива высчитыванию `width: calc(100% - 48px)`, если [нужно «компенсировать» отступы](https://fullystacked.net/stretch/) у `100%` ширины
- есть такие моменты во фронтендерских буднях, на которые можно забить, а можно [мимикрокодилом улучшить интерфейс по-мелочи](https://medienbaecker.com/articles/focus-outlines): много времени не займёт, конечному пользователю будет приятнее; вот, например, `outline` — его обычно выключают, чтобы убрать «проблему», но ведь можно его оставить, но при этом сделать симпатичным: показывать по `:focus-visible`, выставить цвет `currentcolor`, сделать элемент «блочным», немного скруглить углы, задать `outline-offset` и возможно немного его анимировать

**HTML**

- [ещё одна статья](https://evilmartians.com/chronicles/html-best-practices-for-login-and-signup-forms) к подтверждению предыдущей мысли: расставить HTML-атрибуты или обернуть чекбоксы в лейблы, а кнопки в формы несложно, но пользовательский опыт улучшится и на мобильных, и на десктопных платформах
- недавно ставший с выходом FF повсеместно доступный атрибут `fetchpriority` [помогает браузеру понять](https://web.dev/articles/fetch-priority), какие ресурсы грузить первым приоритетом (LCP-картинку), а какие можно отложить (второстепенные скрипты и стили); интересный приём — прелоадим стили с низким приоритетом без блокирования рендера `<link rel="preload" as="style" href="theme.css" fetchpriority="low" onload="this.rel='stylesheet'">`

**Платформа**

- ответ на вопрос собеседования «[что происходит, когда вы набираете адрес сайта в браузере](https://abhisaha.com/blog/exploring-browser-rendering-process)»: DNS Lookup → TCP/TLS Handshake → HTTP Request/Response Cycle → Tokenization → DOM Tree Creation → CSSOM Tree Creation → Render Tree Creation → Layout → Painting
- вы наверняка сталкивались уже с проектом [webstatus.dev](https://webstatus.dev), где показывается в скольких процентах браузеров поддерживаются те или иные фичи; так вот к этим данным есть API [api.webstatus.dev](https://api.webstatus.dev) (описание [схемы openapi](https://github.com/GoogleChrome/webstatus.dev/blob/main/openapi/backend/openapi.yaml)) на поиграться
