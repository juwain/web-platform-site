---
title: Пульс веб-платформы 21.03.2025
description: Новости веб-платформы
pubDate: Mar 21 2025
heroImage: /blog-placeholder-pulse.jpg
tags:
  - Пульс_веб_платформы
---

### Новости

- [в Bun v1.2.5](https://bun.sh/blog/bun-v1.2.5) стала достпна поддержка Svelte и CSS modules в бандлере и дев-сервере
- как и в случае Node.js vs Bun/Deno, [в мире линтеров образуется похожая ситуация](https://oxc.rs/blog/2025-03-15-oxlint-beta.html): к противостоянию ESLint vs Biome присоединяется вышедший в бету Oxlint, который написан на Rust, поэтому оч быстрый, >500 правил работает из коробки, есть автофиксы + планируют запилить поддержку кастомных ESLint-плагинов
- у Vercel есть Next.js, а [у Netlify теперь есть TanStack Start](https://www.netlify.com/blog/tanstack-start-netlify-official-deployment-partner/) и это хорошо и для TanStack, так как будет деньги, и для нас, так как будет альтернатива пропушиваемой парадигме RSC, то есть появляется неиллюзорная возможность появления полноценного React-фреймворка «здорового человека»:
  - в TanStack типобезопасные роуты благодаря дому, что роуты основаны не на файлах, а на функциях, которые создают роуты
  - серверные функции тоже более явные и гибкие, в отличие от директивы "use server"
  - нативная интеграция с TanStack Query
- в [Safari Technology Preview 215](https://webkit.org/blog/16523/release-notes-for-safari-technology-preview-215/) появились Scroll Driven Animations (итого в Chrome уже есть, в FF есть за флагом), CSS Anchor Positioning (в FF нет) и на десерт `text-wrap-style: pretty`
- [проект styled-components переведён в режим поддержки](https://opencollective.com/styled-components/updates/thank-you), так как Context API не поддерживается в серверных компонентах, экосистема в целом ушла в сторону другого подхода к написанию стилей (атомизация стилей, jit-сборка), мейнтейнер сам перестал использовать styled-components в больших приложениях. Это, в целом, ничего страшного, если нравится такой подход к написанию стилей (мне нравится, так позволяют часть UI логики пробрасывать внутрь стилевых компонентов) есть build-time решения со styled-like API (linaria, panda css)
- [Parcel v2.14.0](https://parceljs.org/blog/v2-14-0/) стал поддерживать рендер React Server Components в CSR, SSR или в build-time просто в HTML, заодно стали глубоко поддерживать MDX, и кроме того, появился инструмент миграции проекта с CRA `npx cra-to-parcel`

### Проекты

- [eslint-plugin-eslint-plugin](https://github.com/eslint-community/eslint-plugin-eslint-plugin) — ESLint-плагин для линтинга ESLint-плагинов, если желаете разработать свой, то может подсобить
- [vite-bundle-analyzer](https://github.com/nonzzz/vite-bundle-analyzer) — визуальная и CLI-утилита для инспекции содержимого вашего Vite-бандла

### Статьи и демки

#### JS

- прикол: в JS символы `<!--` и `-->` из-за проблем с легаси-совместимостью — [это валидные символы](https://www.hillelwayne.com/post/javascript-puzzle/) для создания комментария
- Document Picture-in-Picture API может быть использовано не только для показа видео-контента в отдельном окошке, в [PiP можно рендерить своё кастомное содержимое](https://developer.chrome.com/blog/document-pip-use-case):

```js
const pipWindow = await documentPictureInPicture.requestWindow({
  width: window.innerWidth,
  height: window.innerHeight,
});

pipWindow.document.documentElement.innerHTML = htmlCode;
```

- [ещё один наброс на Next.js vs Vite + TanStack](https://www.kylegill.com/essays/next-vs-tanstack/) от человека, который устал скрестись о комплексность API и хочет, чтобы оно просто работало и на клиенте, и на сервере
- если вы не поддались искушению мигрировать на Biome или Oxlint, а хотите сквозь тернии мигрировать таки ваш проект на 9 версию ESLint, то тут [предлагают чеклист миграции](https://www.neoxs.me/blog/migration-to-eslint-v9); я пытался в миграцию полгода назад, но не осилил, так как не были готовы основные сторонние плагины, может быть пора попробовать снова
- [практические юзкейсы утилитарных типов в TS](https://piccalil.li/blog/real-world-uses-of-typescripts-utility-types/):
  - [`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype) в случае, если не хочется при добавлении новых полей в тип, ходить по всем местам и править это; правда встроенный Partial распространяется только на один уровень вложенности, но «[deep partial](https://millsp.github.io/ts-toolbelt/modules/object_partial.html)» из стороннего [ts-toolbet](https://github.com/millsp/ts-toolbelt)
  - [`Omit`](https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys) для типизации объекта, ещё не сохранённого в БД, то есть у него есть все поля, кроме id
  - [`ReturnType`](https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype) для вытаскивания типа, который возвращает функция
  - [`Readonly`](https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype) для типизации копии объекта, которую нельзя модифицировать

#### CSS

- псевдокласс `:in-range` позволяет подвязаться на то, что значение в инпуте [находится в пределах](https://html-css-tip-of-the-week.netlify.app/tip/in-range/) значений, заданных в `min` и `max`
- если [попробовать растянуть элемент](https://til.simonwillison.net/css/dialog-full-height) `<dialog>` на всю высоту вьюпорта, то можно упереться в дефолтное браузерное значение `max-height: calc(100% - 2em - 6px)`, которое надо вручную перезадать на желаемое
- почему так сложилось — хз, тут так заведено, но [есть несколько способов управлять буллетами в списках](https://css-tricks.com/styling-counters-in-css/): псевдоэлемент `::marker`, свойство `list-style-type`, счётчик  `counter()` и его стилизация через `@counter-style`, изображение в `list-style-image` или же старый-добрый `::before
- [эффект «расколотого» на части изображения](https://css-tip.com/assemble-image/) через `mask` и `conic-gradient` не испортишь добавлением `transition`
- если хотите попробовать [встроенные межстраничные `View Transitions`](https://www.amitmerchant.com/bare-minimum-view-transitions/) достаточно добавить `<meta name="view-transition" content="same-origin" />` и `@view-transition { navigation: auto }`

### Платформа

- чем больше уровней абстракций люди строят в технологиях (энергия → чип → сервер → веб-платформа → препроцессоры → библиотеки → фреймворки…), тем больше софта требуется, чтобы это всё обслуживать; [поэтому AI не лишит нас работы](https://seldo.com/posts/ai-effect-on-programming-jobs) (ведь даже сейчас есть работа для программистов Ассемблера), а просто кратно увеличит количество разработчиков, которые будут делать ещё больше софта ещё более разнообразными способами (возможно менее оплачиваемыми), и этим разработчикам так или иначе всё равно придётся осваивать основы просто другим путём
- [а вот это просто красиво смотреть](https://wattenberger.com/thoughts/our-interfaces-have-lost-their-senses): интерфейсы — как человеческая сущность: тёплые, вязаные, твои
