---
title: "Паттерн Proxy (Прокси), практика: кеширование функции с Proxy"
---

Подробнее разберём пример с «проксированием» функции (функция — это тоже объект). В случае функций через прокси можно перехватывать момент вызова функции (перехватчик `apply`) и, например, манипулировать аргументами до вызова.

```js
const func = () => {};

const proxyFunc = new Proxy(func, {
  apply: (target, thisArg, argumentsList) => {
    // перехватчик вызова
    console.log(`Вызвана функция ${func} с параметрами ${argumentsList}`);
  },
});

proxyFunc(1, 2);
// Вызвана функция () => {} с параметрами 1,2
```

До вызова функции мы получаем референс на саму функцию, контекст и массив агрументов и можем с ними делать что угодно перед тем, как непосредственно вызвать (или даже не вызвать) функцию. К примеру, можно организовать кэш, чтобы по переданному набору аргументов запомнить вычисленное значение и при повторном вызове брать его из кэша.

```js
function memoize(fn) {
  const cache = new Map();

  return new Proxy(fn, {
    apply: (fn, _, args) => {
      const key = JSON.stringify(args);

      // если результат есть в кэше, возвращаем его
      /* ... */

      const result = fn(...args);

      // записываем результат в кэш
      /* ... */

      return result;
    },
  });
}

// «Медленная» функция
const add = (a, b) => a + b;

// Мемоизированная версия
const memoizedAdd = memoize(add);

memoizedAdd(3, 7); // Вычисляет и записывает в кэш
memoizedAdd(3, 7); // Берёт результат из кэша
```

Аргументами функции, то есть и ключами в кэше могут быть не только примитивы, но и объекты, за счёт того, что ключ формируется с помощью `JSON.stringify`.

Таким образом, с помощью `Proxy` можно на коленке собрать «мидлвари» для объектов, массивов и функций, в общем-то, с любыми целями.

Реализуйте в модуле `lib.js` функцию `memoize` так, чтобы:

- перед возвращением результата вычисления он записывался в кэш

```js
cache.set(key, result);
```

- перед вычислением проверялось наличие результата в кэше:

```js
if (cache.has(key)) {
  console.log(`Результат для ${args} взят из кэша`);
  return cache.get(key);
}
```
