---
title: "Паттерн Proxy (Прокси), практика: кеширование функции с Proxy"
---

Подробнее разберём пример с «проксированием» функции (функция — это тоже объект). В случае функций через `Proxy` можно перехватывать момент вызова функции (перехватчик `apply`) и, например, манипулировать аргументами до вызова.

```ts
const func = () => {};

const proxyFunc = new Proxy(func, {
  apply: (func, _, args) => {
    // перехватчик вызова
    console.log(`Вызвана функция ${func} с параметрами ${args}`);
  },
});

proxyFunc(1, 2);
// Вызвана функция () => {} с параметрами 1,2
```

До вызова функции мы получаем референс на саму функцию, контекст и массив агрументов и можем с ними делать что угодно перед тем, как непосредственно вызвать (или даже не вызвать) функцию. К примеру, можно организовать кеш, чтобы по переданному набору аргументов запомнить вычисленное значение и при повторном вызове брать его из кеша.

```ts
function memoize<T extends (...args: any[]) => any>(fn: T): T {
  const cache = new Map<string, ReturnType<T>>();

  return new Proxy(fn, {
    apply(target: T, _, args: Parameters<T>): ReturnType<T> {
      const key = JSON.stringify(args);

      // если результат есть в кеше, возвращаем его
      /* ... */

      const result = target(...args);

      // записываем результат в кеш
      /* ... */

      return result;
    },
  });
}

// «Медленная» функция
const add = (a: number, b: number) => a + b;

// Мемоизированная версия
const memoizedAdd = memoize(add);

memoizedAdd(3, 7); // Вычисляет и записывает в кеш
memoizedAdd(3, 7); // Берёт результат из кеша
```

Аргументами функции, то есть и ключами в кеше могут быть не только примитивы, но и объекты, за счёт того, что ключ формируется с помощью `JSON.stringify`.

Таким образом, с помощью `Proxy` можно на коленке собрать «мидлвари» для объектов, массивов и функций, в общем-то, с любыми целями.

Реализуйте в модуле `lib.ts` функцию `memoize` так, чтобы:

- перед возвращением результата вычисления он записывался в кеш:

```ts
cache.set(key, result);
```

- перед вычислением проверялось наличие результата в кеше:

```ts
if (cache.has(key)) {
  console.log(`Результат для ${args} взят из кеша`);

  return cache.get(key);
}
```
